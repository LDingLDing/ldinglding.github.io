<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>组件设计修炼之道 | Luhui's Personal Website</title><meta name="author" content="Luhui芦荟"><meta name="copyright" content="Luhui芦荟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="组件设计剖析（前序）本文是该系列的开篇一，在开始前，我想聊聊这个系列将做什么、希望达成什么样的目标，以及未来如何不断挖坑。 市面上有非常多的独立组件、组件框架，身为开发者我们最常做的是被市场调教 API 使用习惯，我们会局限于一类常用的组件暴露出来的使用方式而难以去适应另一类组件，就像是一个个社交群，如果你一往而深地融入 A ，就难以去接受 B ，而你创造的文化（组件）也在不断的加深这个文化圈。身">
<meta property="og:type" content="article">
<meta property="og:title" content="组件设计修炼之道">
<meta property="og:url" content="https://blog.liluhui.cn/2020/02/06/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%BC%80%E7%AF%87%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="Luhui&#39;s Personal Website">
<meta property="og:description" content="组件设计剖析（前序）本文是该系列的开篇一，在开始前，我想聊聊这个系列将做什么、希望达成什么样的目标，以及未来如何不断挖坑。 市面上有非常多的独立组件、组件框架，身为开发者我们最常做的是被市场调教 API 使用习惯，我们会局限于一类常用的组件暴露出来的使用方式而难以去适应另一类组件，就像是一个个社交群，如果你一往而深地融入 A ，就难以去接受 B ，而你创造的文化（组件）也在不断的加深这个文化圈。身">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liluhui.oss-cn-hangzhou.aliyuncs.com/assets/imgs/eHcJbx.png">
<meta property="article:published_time" content="2020-02-06T14:35:19.000Z">
<meta property="article:modified_time" content="2023-09-01T14:36:56.649Z">
<meta property="article:author" content="Luhui芦荟">
<meta property="article:tag" content="组件设计">
<meta property="article:tag" content="Input">
<meta property="article:tag" content="输入框">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liluhui.oss-cn-hangzhou.aliyuncs.com/assets/imgs/eHcJbx.png"><link rel="shortcut icon" href="https://i.loli.net/2017/11/26/5a19c0b50432e.png"><link rel="canonical" href="https://blog.liluhui.cn/2020/02/06/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%BC%80%E7%AF%87%E4%B8%80%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=8Z2NNDYTL9"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', '8Z2NNDYTL9')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', '8Z2NNDYTL9', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '组件设计修炼之道',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-01 22:36:56'
}</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/rss2.xml" title="Luhui's Personal Website" type="application/rss+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://liluhui.oss-cn-hangzhou.aliyuncs.com/assets/imgs/C31A6047.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">97</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 文章归档</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/process"><span> 建站历程</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://liluhui.oss-cn-hangzhou.aliyuncs.com/assets/imgs/eHcJbx.png);"><nav id="nav"><span id="blog-info"><a href="/" title="Luhui's Personal Website"><span class="site-name">Luhui's Personal Website</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 文章归档</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/process"><span> 建站历程</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">组件设计修炼之道</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-02-06T14:35:19.000Z" title="发表于 2020-02-06 22:35:19">2020-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-01T14:36:56.649Z" title="更新于 2023-09-01 22:36:56">2023-09-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="组件设计修炼之道"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="组件设计剖析（前序）"><a href="#组件设计剖析（前序）" class="headerlink" title="组件设计剖析（前序）"></a>组件设计剖析（前序）</h2><p>本文是该系列的开篇一，在开始前，我想聊聊这个系列将做什么、希望达成什么样的目标，以及未来如何不断挖坑。</p>
<p>市面上有非常多的独立组件、组件框架，身为开发者我们最常做的是被市场调教 API 使用习惯，我们会局限于一类常用的组件暴露出来的使用方式而难以去适应另一类组件，就像是一个个社交群，如果你一往而深地融入 A ，就难以去接受 B ，而你创造的文化（组件）也在不断的加深这个文化圈。身处“改变世界”伟大理想的一名壮士，我们需要一起去探索各种组件设计及架构的“同”与“不同”，探索那些历史遗留的不好，挖掘那些新兴的好、复古的好，辩证看那些组件设计中的“纠结点”，给更多基础建设开发者参考，让整个大社群往更好的方向走。因为在这个当下，很多“好”是不被习惯的，它需要时间给予变迁。</p>
<p>想借这个系列，跟大家一起去多看看各种组件的设计思路， 我们很难界定组件建设到底属于基础建设还是业务复用性封装，从大环境来看，越是基础的建设越是稳定，而越是接近使用层，那些更需要考虑人性化的东西越是百花齐放。我们在经验中也发现，公司的业务项目更多地选择自己创造组件，而后台项目则会更多使用市面上的框架，有的框架很基础自定义程度太高，我们会抱怨，有的框架封装程度很高，总会遇到不匹配的场景，我们也抱怨。为什么，为什么不会有刚刚好的组件？这其中有太多设计之初的考虑、圈定的范围，一个优秀的组件要考虑的实在太多了，而大多数，能用就好。</p>
<p>这恰恰也是我们需要警觉的，我们在创造组件的过程中，是否只是在自己的认知圈内创作，是否需要去调研市面上更多的实践，是否要去挖掘你所身处的团队的认知能力水平。在创作组件之前，是设计组件，不是一味地照抄某一框架，我们需要认识到，最合适你的团队现在和未来的，是最了解自身业务和未来变化的你，不是市场上的任何框架。</p>
<p>&amp;nbsp;</p>
<p>这是第一次做一个系列，当然过程中可能产生一些错误（我会尽量避免），希望大家一起帮助它做的更好。开该系列的目的，是想和大家一起去学习市面上主流组件设计的理念、实现方式、抉择，继往开来做得更好。</p>
<p>&amp;nbsp;</p>
<p>本系列<strong>将视角着重于 Vue 体系 PC 端 UI 框架</strong>，选取有国内 <a target="_blank" rel="noopener" href="https://element.eleme.cn/">ElementUI</a>、<a target="_blank" rel="noopener" href="http://iview.talkingdata.com/">iView</a>、<a target="_blank" rel="noopener" href="https://muse-ui.org/">muse-ui</a>， 国外 <a target="_blank" rel="noopener" href="https://vuetifyjs.com/">Vuetify</a>、<a target="_blank" rel="noopener" href="https://quasar.dev/">quasar</a> 这五个框架， 选取标准为当前 Github star 数为参考。</p>
<p>下图为写文当前各框架版本情况及 star 数</p>
<table>
<thead>
<tr>
<th>框架</th>
<th>version</th>
<th>star</th>
</tr>
</thead>
<tbody><tr>
<td>ElementUI</td>
<td>2.13.0</td>
<td>43.7k</td>
</tr>
<tr>
<td>iView</td>
<td>3.5.4</td>
<td>23k</td>
</tr>
<tr>
<td>Muse-UI</td>
<td>3.0.0-beta.4</td>
<td>7.9k</td>
</tr>
<tr>
<td>Vuetify</td>
<td>2.2.9</td>
<td>23.6k</td>
</tr>
<tr>
<td>Quasar</td>
<td>1.8.5</td>
<td>13.5k</td>
</tr>
</tbody></table>
<p>&amp;nbsp;</p>
<p>本文是开篇一，不会过于复杂，我们从一个小视角来窥探组件设计，就从一个 input 组件的设计来聊聊差异。在这个过程中，会不停地挖坑，作为之后的选材内容，能不能继续更就看奶茶够不够了。</p>
<h2 id="一个-Input-组件需要哪些功能"><a href="#一个-Input-组件需要哪些功能" class="headerlink" title="一个 Input 组件需要哪些功能"></a>一个 Input 组件需要哪些功能</h2><p>我们来一起梳理一下，一个 Input 组件需要哪些功能。接下来我将功能需求归为三类，其中第一类最为基础，基本与底层规范一致；第二类的功能更具有一个时代视觉和交互的惯性；第三类则更个性化，各框架有自己更多的考虑和取舍，争议也最多。</p>
<p>总的来说，划分出的三类，一类是这个组件必须要有功能，二类大概率是这个组件应该有的功能，三类是可以让这个组件做的更好&#x2F;坏的。越基础，越是通用。</p>
<p>&amp;nbsp;</p>
<p>在开始之前，基础方向上就有几点需要明确</p>
<p>⑴ Input 组件不包含 type 为 button、checkbox、file、radio、file、datepicker 的情况，这些划分为独立组件</p>
<p>⑵ Input 组件是否要包含 textarea 的情况 <a href="#Q1">Link Q1</a></p>
<p>⑶ Input 组件由于要考虑复合情况，常见的其中带有icon、按钮等，其本身需要包装成 div ，那么对于它的命名和定位究竟应该叫 <strong>输入框(Input)</strong> 还是 <strong>本文框(TextFields)</strong> ， 哪种更合理？ <a href="#Q2">Link Q2</a></p>
<h3 id="一类功能"><a href="#一类功能" class="headerlink" title="一类功能"></a>一类功能</h3><blockquote>
<p>一类功能属于基础中的基础，这个层次优秀的组件应该是相似的好</p>
</blockquote>
<h4 id="一、-原生属性系列，常用的原生功能需要暴露给调用者"><a href="#一、-原生属性系列，常用的原生功能需要暴露给调用者" class="headerlink" title="一、 原生属性系列，常用的原生功能需要暴露给调用者"></a>一、 原生属性系列，常用的原生功能需要暴露给调用者</h4><ul>
<li><strong>类型 type</strong><br>text 为默认，可选 password、number、color 等，按照 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types">html5 规范</a>实现</li>
<li><strong>占位文本 placeholder</strong></li>
<li><strong>值 value</strong></li>
<li><strong>只读模式 readonly</strong><br>只读模式和禁用模式在视觉交互上的差异设计是否需要 <a href="#Q3">Link Q3</a></li>
<li><strong>禁用模式 disabled</strong><br>只读模式和禁用模式在视觉交互上的差异设计是否需要 <a href="#Q3">Link Q3</a></li>
<li><strong>自动聚焦 autofocus</strong></li>
</ul>
<h4 id="二、-常规事件，包括"><a href="#二、-常规事件，包括" class="headerlink" title="二、 常规事件，包括"></a>二、 常规事件，包括</h4><ul>
<li><strong>聚焦 fucos</strong> </li>
<li><strong>失焦 blur</strong></li>
<li><strong>选择文本 select</strong></li>
<li><strong>输入时 input</strong></li>
<li><strong>键盘事件 keydown、keyup、keypress</strong></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>ElementUI</th>
<th>iView</th>
<th>Muse-UI</th>
<th>Vuetify</th>
<th>Quasar</th>
</tr>
</thead>
<tbody><tr>
<td>focus</td>
<td>O</td>
<td>O</td>
<td></td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>blur</td>
<td>O</td>
<td>O</td>
<td></td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>select</td>
<td>O</td>
<td></td>
<td></td>
<td>▲</td>
<td>▲</td>
</tr>
<tr>
<td>input</td>
<td>O</td>
<td>O (对应事件名 change)</td>
<td>O (对应事件名 change)</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>keydown</td>
<td></td>
<td>O</td>
<td></td>
<td>O</td>
<td>▲</td>
</tr>
<tr>
<td>keyup</td>
<td></td>
<td>O</td>
<td></td>
<td>▲</td>
<td>▲</td>
</tr>
<tr>
<td>keypress</td>
<td></td>
<td>O</td>
<td></td>
<td>▲</td>
<td>▲</td>
</tr>
<tr>
<td>对拼音输入法处理  compositionxxx</td>
<td>O</td>
<td>O</td>
<td></td>
<td></td>
<td>O</td>
</tr>
<tr>
<td>防抖处理 debounce</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>O</td>
</tr>
</tbody></table>
<p>以上是很基本的五个事件，各框架的实现情况如上表整理</p>
<p>O 表示支持或有处理<br>▲ 表示源码中对所有传入事件都做了传递处理，即原生事件全部支持<br>&amp;nbsp;</p>
<ul>
<li><p>可以看到对键盘事件 <strong>keyxxx</strong> 大多没实现，这意味着调用者无法在该组件基础上做更多快捷键工作；</p>
</li>
<li><p><strong>select</strong> 事件也是大多忽略的事件，我们在需求场景中有时也需要用到，比如选中快速（自动）复制；</p>
</li>
<li><p><strong>compositionxxx</strong> 国内框架理应处理拼音输入法的情况，如果没做不是经验不足就是懒，印象分极差；</p>
</li>
<li><p><strong>debounce</strong> 防抖处理调查结果是比较意外的，竟然只有一家做了；（扩展问题：防抖频率设置多少最佳 <a href="#Q4">Link Q4</a>）</p>
</li>
<li><p>当然在这些框架中也有很多积极的想法，比如封装提供回车事件、对鼠标事件进行更多的封装。</p>
</li>
</ul>
<p>&amp;nbsp;</p>
<h4 id="三、-若有所思"><a href="#三、-若有所思" class="headerlink" title="三、 若有所思"></a>三、 若有所思</h4><p>对比这几个框架，我们有几个问题</p>
<p>&amp;nbsp;</p>
<h5 id="㈠-事件名-change-和-input-的定义不全一致"><a href="#㈠-事件名-change-和-input-的定义不全一致" class="headerlink" title="㈠ 事件名 change 和 input 的定义不全一致"></a>㈠ 事件名 change 和 input 的定义不全一致</h5><p>① input 表示值改变： ElementUI、Vuetify、Quasar<br>② change 表示值改变： iView、Muse-UI、<br>③ change 同<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Events/change">原生 change 事件</a>：Vuetify、ElementUI</p>
<table>
<thead>
<tr>
<th></th>
<th>input</th>
<th>change</th>
</tr>
</thead>
<tbody><tr>
<td>ElementUI</td>
<td>①</td>
<td>③</td>
</tr>
<tr>
<td>iView</td>
<td>①</td>
<td>②</td>
</tr>
<tr>
<td>Muse-UI</td>
<td></td>
<td>②</td>
</tr>
<tr>
<td>Vuetify</td>
<td>①</td>
<td>③</td>
</tr>
<tr>
<td>Quasar</td>
<td>①</td>
<td>&amp;nbsp;</td>
</tr>
</tbody></table>
<p>我们可以看到对 input 事件的使用是一致的，从一方面来说这是 Vue 官方给出的默认实践方案（如下图），采用 input 事件与 v-model 绑定，对于熟知该规范的人较为友好；从另一方面——语义化理解来说，change 更为贴近 v-model 绑定值改变的含义；再从另一角度——原生 onchange，仅在失焦时才触发，对应的理解是“我输入完了”。这么多看法真让人迷惑，语义化和实际的结合怎么这么混乱。</p>
<img src="/2020/02/06/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%BC%80%E7%AF%87%E4%B8%80%EF%BC%89/046DA623-4F73-4CC2-A7B5-E478B4236D7C.png" class="" width="731" height="99">

<p>综上，我们要角逐的问题是</p>
<ul>
<li><strong>要遵循原生 change 的定义</strong> vs <strong>原生 change 设计不合理</strong></li>
<li><strong>input 是值改变</strong> vs <strong>change 是值改变</strong></li>
</ul>
<p>&amp;nbsp;</p>
<p>这里我建议使用 <strong>change 是值改变</strong>，并且 <strong>input 也是值改变</strong>，理由如下</p>
<ol>
<li>change 最贴近语义使用，新手友好</li>
<li>实际使用中，原生 onchange 大多被当做值改变而入手去使用，最终踩坑换方案</li>
<li>前时代的框架 jQuery 都将 change 事件处理为了值改变，并不遵循原始含义</li>
<li>input 由于在 Vue 中是 v-model 的默认绑定事件，被大多数被 Vue 调教熟悉的用户所熟悉，可以保留</li>
</ol>
<p>&amp;nbsp;</p>
<h5 id="㈡-事件命名规范"><a href="#㈡-事件命名规范" class="headerlink" title="㈡ 事件命名规范"></a>㈡ 事件命名规范</h5><ul>
<li>ElementUI、Muse-UI、Vuetify、Quasar 均采用<strong>直接动词</strong>，如 <strong>focus</strong>、<strong>blur</strong></li>
<li>iView 采用 <strong>on-动词</strong>，如 <strong>on-focus</strong>、<strong>on-blur</strong></li>
</ul>
<img src="/2020/02/06/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%BC%80%E7%AF%87%E4%B8%80%EF%BC%89/3B4BC914-1FC0-40E3-B641-02CB58FDCD05.png" class="" width="437" height="26">


<p>更推荐使用<strong>直接动词</strong>，原因如下：</p>
<ol>
<li>Vue 中事件绑定采用的写法是 <code>v-on:focus</code> 或简写 <code>@focus</code>， 在此基础上 on 显得多次一举</li>
<li>据我观察市面上 90% 的都是直接动词（90%当然是乱编的），尽可能减少认知偏差</li>
</ol>
<p>&amp;nbsp;</p>
<h5 id="㈢-所有的事件属性是否通过-attrs、-listeners-一次传入"><a href="#㈢-所有的事件属性是否通过-attrs、-listeners-一次传入" class="headerlink" title="㈢ 所有的事件属性是否通过 $attrs、$listeners 一次传入"></a>㈢ 所有的事件属性是否通过 $attrs、$listeners 一次传入</h5><p>埋个坑，有机会再聊。<a href="#Q5">link Q5</a></p>
<p>&amp;nbsp;</p>
<h3 id="二类功能"><a href="#二类功能" class="headerlink" title="二类功能"></a>二类功能</h3><blockquote>
<p>这个层次封装了大部分市面上常用的情况，有当下的时代惯性，各个组件已经能体现出设计方案上的差别和针对性。</p>
</blockquote>
<h4 id="一、-封装清除按钮"><a href="#一、-封装清除按钮" class="headerlink" title="一、 封装清除按钮"></a>一、 封装清除按钮</h4><p>如下图，给输入框带上清除按钮，是当下非常普遍的一种交互形式。</p>
<img src="/2020/02/06/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%BC%80%E7%AF%87%E4%B8%80%EF%BC%89/1.1.gif" class="" width="367" height="169">


<table>
<thead>
<tr>
<th></th>
<th>字段名</th>
<th>默认值</th>
<th>icon独立占位</th>
<th>显示触发条件</th>
<th>鼠标形式</th>
</tr>
</thead>
<tbody><tr>
<td>ElementUI</td>
<td>clearable</td>
<td>false</td>
<td>O</td>
<td>有内容时 &amp;&amp; （鼠标移入 or 聚焦）</td>
<td>pointer</td>
</tr>
<tr>
<td>iView</td>
<td>clearable</td>
<td>false</td>
<td>X</td>
<td>有内容时 &amp;&amp; 鼠标移入</td>
<td>default</td>
</tr>
<tr>
<td>Muse-UI</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Vuetify</td>
<td>clearable</td>
<td>false</td>
<td>O</td>
<td>有内容时</td>
<td>pointer</td>
</tr>
<tr>
<td>Quasar</td>
<td>clearable</td>
<td>false</td>
<td>O</td>
<td>有内容时</td>
<td>pointer</td>
</tr>
</tbody></table>
<p>调研框架结果如上图，几个点</p>
<ul>
<li><p>㈠ 字段名一致为 <strong>clearable</strong>，无争议</p>
</li>
<li><p>㈡ 默认值均为 <strong>false</strong>，无争议</p>
</li>
<li><p>㈢ 鼠标形式</p>
</li>
</ul>
<img src="/2020/02/06/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%BC%80%E7%AF%87%E4%B8%80%EF%BC%89/4282CBE8-25AD-42CA-BC34-779781CB2106.png" class="" width="142" height="58">
<p>从严格交互规范来讲，可点击态应统一使用 <code>pointer</code> 。但考虑到历史原因角度来讲，当视觉已经给予明确可点击形式的情况下，可以无需使用 <code>pointer</code> 形式。正如浏览器默认给 button 设置的是 default，而像 link 这样和文本混淆在一起的可点击态则默认会设置为 pointer，以增强用户的理解。</p>
<img src="/2020/02/06/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%BC%80%E7%AF%87%E4%B8%80%EF%BC%89/05A6C2B8-E61D-4F14-8360-AF694595AE84.png" class="" width="320" height="268">

<img src="/2020/02/06/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%BC%80%E7%AF%87%E4%B8%80%EF%BC%89/8F43391D-E3B2-45FD-9788-1FBF7727E12E.png" class="" width="336" height="116">

<p>所以，我的建议是，框架需要为自身的鼠标 cursor 使用设定规范，包括明确目标群体对交互习惯的认知程度，及每个部位在视觉上可点击态的认知感程度，比如带阴影的 button 是强可点击态的，鼠标手势意义不大。整个过程的平衡点在于 “鼠标强烈存在感所造成的突兀感（俗称丑）”和 “交互认知感更强”上。但一定，一定要有自身的规范约束。</p>
<ul>
<li>㈣ 事件监听</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>独立定义事件</th>
<th>触发值改变事件</th>
<th>change（同原生事件）的表现</th>
</tr>
</thead>
<tbody><tr>
<td>ElementUI</td>
<td>clear</td>
<td>input</td>
<td>不失焦，change会触发</td>
</tr>
<tr>
<td>iView</td>
<td>on-clear</td>
<td>input, on-change</td>
<td>-</td>
</tr>
<tr>
<td>Muse-UI</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Vuetify</td>
<td>click:clear</td>
<td>input</td>
<td>不失焦，change不会触发</td>
</tr>
<tr>
<td>Quasar</td>
<td>clear</td>
<td>input</td>
<td>-</td>
</tr>
</tbody></table>
<p>提供独立定义和触发值改变事件这两点都是一致的最佳实践。</p>
<p>在事件命名体系中，我们看到 Vuetify 有内部自洽的一套规范，个人立场上还挺喜欢的。组件体系事件设计方案 <a href="#Q6">Link Q6</a>。</p>
<p>change 事件按照原生规范的两个框架 Ele 和 Vuetify 在这里的表现并不一致，正如上文所建议的那样，原生 change 在使用中开发者明显容易踩坑，这点上还是建议避免遵循原生，在细节的处理上会显得非常两难。</p>
<p>&amp;nbsp;</p>
<h4 id="二、-前-x2F-后置内容"><a href="#二、-前-x2F-后置内容" class="headerlink" title="二、 前&#x2F;后置内容"></a>二、 前&#x2F;后置内容</h4><p>如下图，常规情况有输入框内部前后带有 icon ，或是输入框外部（并排）带有按钮等操作。</p>
<img src="/2020/02/06/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%BC%80%E7%AF%87%E4%B8%80%EF%BC%89/1.3.gif" class="" width="391" height="266">

<img src="/2020/02/06/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%BC%80%E7%AF%87%E4%B8%80%EF%BC%89/1.gif" class="" width="248" height="34">

<p>对于块形态（边框和色块）的输入框，前&#x2F;后置内容分为 <strong>输入聚焦时高亮[内部]的前&#x2F;后置内容</strong> 和  <strong>输入聚焦时高亮[外部]的前&#x2F;后置内容</strong>；</p>
<p>对于下划线形态的，由于无需封装处理积木(组件)组合情况时各积木能否拼接上(尺寸)，基础通用下仅需封装 <strong>输入聚焦时高亮[内部]的前&#x2F;后置内容</strong> 。</p>
<p>&amp;nbsp;</p>
<p>调研的几个框架里， Muse-UI 和 Vuetify 较为特别，由于视觉交互规范定义在下划线形态聚焦时，外部 icon 也需要一致高亮（如下图），这两者都封装了 <strong>外部前&#x2F;后置 Icon 字段</strong>，算是【三类功能】里的，我们后文再聊</p>
<img src="/2020/02/06/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%BC%80%E7%AF%87%E4%B8%80%EF%BC%89/1.2.gif" class="" width="248" height="34">

<p>&amp;nbsp;</p>
<table>
<thead>
<tr>
<th></th>
<th>形态（下划线&#x2F;框）</th>
<th>内部前&#x2F;后置字段(slot)</th>
<th>外部前&#x2F;后置字段(slot)</th>
<th>内部前&#x2F;后置Icon字段</th>
<th>外部前&#x2F;后置Icon字段</th>
<th>内部前&#x2F;后置文本字段</th>
</tr>
</thead>
<tbody><tr>
<td>ElementUI</td>
<td>X&#x2F;O</td>
<td>prefix&#x2F;suffix</td>
<td>prepend&#x2F;append</td>
<td>prefix-icon&#x2F;suffix-icon</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>iView</td>
<td>X&#x2F;O</td>
<td>prefix&#x2F;suffix</td>
<td>prepend&#x2F;append</td>
<td>prefix&#x2F;suffix</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Muse-UI</td>
<td>O&#x2F;X</td>
<td>prepend&#x2F;append</td>
<td>-</td>
<td>-</td>
<td>icon&#x2F;action-icon</td>
<td>prefix&#x2F;suffix</td>
</tr>
<tr>
<td>Vuetify</td>
<td>O&#x2F;O</td>
<td>prepend-inner&#x2F;append</td>
<td>prepend&#x2F;append-outer</td>
<td>prepend-inner-icon&#x2F;append-icon</td>
<td>prepend-icon&#x2F;append-outer-icon</td>
<td>prefix&#x2F;suffix</td>
</tr>
<tr>
<td>Quasar</td>
<td>O&#x2F;O</td>
<td>prepend&#x2F;append</td>
<td>before&#x2F;after</td>
<td>-</td>
<td>-</td>
<td>prefix&#x2F;suffix</td>
</tr>
</tbody></table>
<ul>
<li><p>我们在该需求功能下将基本形态分为 <strong>下划线形式</strong>、<strong>线框和色块形式</strong>，两者的业务使用场景都很频繁，通用框架建议都支持。</p>
</li>
<li><p>字段命名看一圈会很懵和混乱，我们先看 slot 的部分。首先，slot 灵活度最高，最佳实践建议都暴露，这里 Muse-UI 做的不好。然后，命名上，两组单词 <strong>prefix&#x2F;suffix</strong> 和 <strong>prepend&#x2F;append</strong>，从<a target="_blank" rel="noopener" href="https://wikidiff.com/prefix/prepend">词汇的定义</a>来说, <strong>prefix&#x2F;suffix</strong> 比  <strong>prepend&#x2F;append</strong> 更贴近一层，这么看国内框架 Ele 和 iView 是比较符合语义的；从语言本身使用来说，这两者可替换性强，国外的用户不查字典可能也不知道差别，所以国际化角度讲，确实应该避免一起使用。</p>
<ul>
<li>这部分我的建议是使用 <strong>prepend-inner&#x2F;append-inner</strong> 和 <strong>prepend&#x2F;append</strong>, 这样的认知应该是最平衡的。</li>
</ul>
</li>
<li><p>Vuetify 在 slot 上的命名不建议，一组 <strong>prepend-inner&#x2F;append</strong>，另一组 <strong>prepend&#x2F;append-outer</strong>，很不和谐，调用者惯性使用上一定会踩坑，需要反复查阅文档。</p>
</li>
<li><p>是否提供前&#x2F;后置 Icon 或 text 的属性设置，取决于各框架判断对于其受众在这两点上复用程度是否高。我的建议是<strong>结合实际</strong>，大多数情况有比没有好，毕竟这点上代码量的增加是微乎其微的。</p>
<ul>
<li>这部分我的建议是使用 <strong>prepend-inner-icon&#x2F;append-inner-icon</strong>、<strong>prepend-icon&#x2F;append-icon</strong>、<strong>prepend-inner&#x2F;append-inner</strong>、<strong>prepend&#x2F;append</strong>，命名规则与 slot 部分保持一致。</li>
</ul>
</li>
<li><p>从代码维护性角度来讲，<strong>外部前&#x2F;后置</strong> 是维护性价比最低的，功能复杂，使用量不算大，尤其是<strong>线框和色块形式</strong>是要对各种可能组装的情形进行微处理，需要更多考量。</p>
</li>
</ul>
<h3 id="三类功能"><a href="#三类功能" class="headerlink" title="三类功能"></a>三类功能</h3><blockquote>
<p>这个层次封装了更多框架自身的定位和创新，我们为什么选择一个框架，很多时候选择它就是靠这样一个“运营的好”的功能。</p>
</blockquote>
<p>&amp;nbsp;</p>
<p>三类涉及的东西较多，为了愉悦的阅读体验，将单独开一篇来谈论，</p>
<p>涉及</p>
<ul>
<li>结合联想弹窗功能</li>
<li>尺寸定义与实现</li>
<li>多行输入 &amp; Textarea</li>
<li>字数限制功能</li>
<li>封装确认&#x2F;搜索按钮</li>
<li>常规事件之外，更精确场景的事件</li>
<li>样式形态的场景考量</li>
<li>输入提示</li>
<li>规则校验</li>
<li>切换密码显示功能</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h3><h4 id="1-常用原生的功能需要暴露给调用者，按照-html5-规范核对一遍，这点最为基础"><a href="#1-常用原生的功能需要暴露给调用者，按照-html5-规范核对一遍，这点最为基础" class="headerlink" title="1. 常用原生的功能需要暴露给调用者，按照 html5 规范核对一遍，这点最为基础"></a>1. 常用原生的功能需要暴露给调用者，按照 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input">html5 规范</a>核对一遍，这点最为基础</h4><p>容易遗漏的有，</p>
<ul>
<li>min, max, step</li>
<li>autofocus</li>
<li>tabindex</li>
</ul>
<h4 id="2-常规事件"><a href="#2-常规事件" class="headerlink" title="2. 常规事件"></a>2. 常规事件</h4><ul>
<li><strong>聚焦 fucos</strong> </li>
<li><strong>失焦 blur</strong></li>
<li><strong>选择文本 select</strong></li>
<li><strong>输入时 input</strong></li>
<li><strong>键盘事件 keydown、keyup、keypress</strong></li>
</ul>
<p>这几个基础事件都要做上，同时别忘了通过 <code>compositionxxx</code> 对拼音输入法处理，以及防抖优化。</p>
<h4 id="3-值改变的事件名"><a href="#3-值改变的事件名" class="headerlink" title="3. 值改变的事件名"></a>3. 值改变的事件名</h4><p>建议 <strong>change 是值改变</strong>，并且 <strong>input 也是值改变</strong>，舍弃原生对 change 的定义。</p>
<h4 id="4-事件命名规范用直接动词"><a href="#4-事件命名规范用直接动词" class="headerlink" title="4. 事件命名规范用直接动词"></a>4. 事件命名规范用直接动词</h4><p>对外提供如 <code>change</code> 而非 <code>on-change</code></p>
<h4 id="5-清除按钮功能"><a href="#5-清除按钮功能" class="headerlink" title="5. 清除按钮功能"></a>5. 清除按钮功能</h4><ul>
<li>字段名为 <strong>clearable</strong>，默认值 <strong>false</strong> 。</li>
<li>对外提供独立事件 <strong>clear</strong>，并且触发值改变事件 <strong>input&#x2F;change</strong>。</li>
<li>鼠标手势的规范未必要用 pointer，更重要的是框架整体需要制定好规范。</li>
</ul>
<h4 id="6-前-x2F-后置内容"><a href="#6-前-x2F-后置内容" class="headerlink" title="6. 前&#x2F;后置内容"></a>6. 前&#x2F;后置内容</h4><ul>
<li>下划线形态 和 块形态 都要提供。</li>
<li>内部前&#x2F;后置 和 外部前&#x2F;后置 slot 都要提供，命名建议 <strong>prepend-inner&#x2F;append-inner</strong> 和 <strong>prepend&#x2F;append</strong> 这两组，不要同时存在 <strong>prefix&#x2F;suffix</strong> 这组单词。</li>
<li>是否提供前&#x2F;后置 Icon 或 text 的属性设置，取决于各框架判断对于其受众在这两点上复用程度是否高。我的建议是<strong>结合实际</strong>，大多数情况有比没有好，毕竟这点上代码量的增加是微乎其微的。</li>
</ul>
<h3 id="挖开的坑"><a href="#挖开的坑" class="headerlink" title="挖开的坑"></a>挖开的坑</h3><h5 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h5><p>Input 组件是否要包含 textarea 的情况</p>
<h5 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h5><p>输入框组件命名和定位究竟应该叫 输入框(Input) 还是 本文框(TextFields) ?</p>
<h5 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h5><p>只读模式和禁用模式在视觉交互上的差异设计是否需要</p>
<h5 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h5><p>防抖频率设置多少最佳</p>
<h5 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h5><p>所有的事件属性通过 $attrs、$listeners 一次传入的利弊</p>
<h5 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h5><p>组件体系事件设计方案探索</p>
<p>&amp;nbsp;<br>&amp;nbsp;</p>
<blockquote>
<p>喝奶茶续命去了，下期有缘再见</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.liluhui.cn">Luhui芦荟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.liluhui.cn/2020/02/06/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%BC%80%E7%AF%87%E4%B8%80%EF%BC%89/">https://blog.liluhui.cn/2020/02/06/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%BC%80%E7%AF%87%E4%B8%80%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.liluhui.cn" target="_blank">Luhui's Personal Website</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/">组件设计</a><a class="post-meta__tags" href="/tags/Input/">Input</a><a class="post-meta__tags" href="/tags/%E8%BE%93%E5%85%A5%E6%A1%86/">输入框</a></div><div class="post-share"><div class="social-share" data-image="https://liluhui.oss-cn-hangzhou.aliyuncs.com/assets/imgs/eHcJbx.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2021/06/26/%E5%85%B3%E4%BA%8E%E8%AF%B4%E6%9C%8D/" title="关于说服"><img class="cover" src="https://liluhui.oss-cn-hangzhou.aliyuncs.com/assets/imgs/20210626-141800.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">关于说服</div></div></a><a class="next-post pull-right" href="/2020/01/28/%E6%88%91%E7%9A%842019/" title="我的2019"><img class="cover" src="https://liluhui.oss-cn-hangzhou.aliyuncs.com/assets/imgs/apEfIu.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">我的2019</div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="https://liluhui.oss-cn-hangzhou.aliyuncs.com/assets/imgs/C31A6047.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Luhui芦荟</div><div class="author-info-description">关于生活、学习、工作</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">97</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="/rss2.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a><a class="social-icon" href="https://github.com/LDingLDing" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:liluhuizj@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%EF%BC%88%E5%89%8D%E5%BA%8F%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">组件设计剖析（前序）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA-Input-%E7%BB%84%E4%BB%B6%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD"><span class="toc-number">2.</span> <span class="toc-text">一个 Input 组件需要哪些功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%B1%BB%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.</span> <span class="toc-text">一类功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E5%8E%9F%E7%94%9F%E5%B1%9E%E6%80%A7%E7%B3%BB%E5%88%97%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8E%9F%E7%94%9F%E5%8A%9F%E8%83%BD%E9%9C%80%E8%A6%81%E6%9A%B4%E9%9C%B2%E7%BB%99%E8%B0%83%E7%94%A8%E8%80%85"><span class="toc-number">2.1.1.</span> <span class="toc-text">一、 原生属性系列，常用的原生功能需要暴露给调用者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E5%B8%B8%E8%A7%84%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%8C%85%E6%8B%AC"><span class="toc-number">2.1.2.</span> <span class="toc-text">二、 常规事件，包括</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E8%8B%A5%E6%9C%89%E6%89%80%E6%80%9D"><span class="toc-number">2.1.3.</span> <span class="toc-text">三、 若有所思</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%88%A0-%E4%BA%8B%E4%BB%B6%E5%90%8D-change-%E5%92%8C-input-%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8D%E5%85%A8%E4%B8%80%E8%87%B4"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">㈠ 事件名 change 和 input 的定义不全一致</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%88%A1-%E4%BA%8B%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">㈡ 事件命名规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%88%A2-%E6%89%80%E6%9C%89%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%B1%9E%E6%80%A7%E6%98%AF%E5%90%A6%E9%80%9A%E8%BF%87-attrs%E3%80%81-listeners-%E4%B8%80%E6%AC%A1%E4%BC%A0%E5%85%A5"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">㈢ 所有的事件属性是否通过 $attrs、$listeners 一次传入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%B1%BB%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">二类功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E5%B0%81%E8%A3%85%E6%B8%85%E9%99%A4%E6%8C%89%E9%92%AE"><span class="toc-number">2.2.1.</span> <span class="toc-text">一、 封装清除按钮</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E5%89%8D-x2F-%E5%90%8E%E7%BD%AE%E5%86%85%E5%AE%B9"><span class="toc-number">2.2.2.</span> <span class="toc-text">二、 前&#x2F;后置内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%B1%BB%E5%8A%9F%E8%83%BD"><span class="toc-number">2.3.</span> <span class="toc-text">三类功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.1.</span> <span class="toc-text">最佳实践建议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B8%B8%E7%94%A8%E5%8E%9F%E7%94%9F%E7%9A%84%E5%8A%9F%E8%83%BD%E9%9C%80%E8%A6%81%E6%9A%B4%E9%9C%B2%E7%BB%99%E8%B0%83%E7%94%A8%E8%80%85%EF%BC%8C%E6%8C%89%E7%85%A7-html5-%E8%A7%84%E8%8C%83%E6%A0%B8%E5%AF%B9%E4%B8%80%E9%81%8D%EF%BC%8C%E8%BF%99%E7%82%B9%E6%9C%80%E4%B8%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. 常用原生的功能需要暴露给调用者，按照 html5 规范核对一遍，这点最为基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. 常规事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%80%BC%E6%94%B9%E5%8F%98%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%90%8D"><span class="toc-number">3.1.3.</span> <span class="toc-text">3. 值改变的事件名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BA%8B%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E7%94%A8%E7%9B%B4%E6%8E%A5%E5%8A%A8%E8%AF%8D"><span class="toc-number">3.1.4.</span> <span class="toc-text">4. 事件命名规范用直接动词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B8%85%E9%99%A4%E6%8C%89%E9%92%AE%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.5.</span> <span class="toc-text">5. 清除按钮功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%89%8D-x2F-%E5%90%8E%E7%BD%AE%E5%86%85%E5%AE%B9"><span class="toc-number">3.1.6.</span> <span class="toc-text">6. 前&#x2F;后置内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%96%E5%BC%80%E7%9A%84%E5%9D%91"><span class="toc-number">3.2.</span> <span class="toc-text">挖开的坑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Q1"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">Q1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Q2"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">Q2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Q3"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">Q3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Q4"><span class="toc-number">3.2.0.4.</span> <span class="toc-text">Q4</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Q5"><span class="toc-number">3.2.0.5.</span> <span class="toc-text">Q5</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Q6"><span class="toc-number">3.2.0.6.</span> <span class="toc-text">Q6</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/29/What-really-happens-when-you-talk-to-an-AI/" title="了解和 AI 对话时真正发生了什么（你可能一直理解错了）">了解和 AI 对话时真正发生了什么（你可能一直理解错了）</a><time datetime="2025-10-29T07:34:03.000Z" title="发表于 2025-10-29 15:34:03">2025-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/24/Agent-Memory-Evaluation-Framework-From-Metrics-to-Open-Benchmarks/" title="Agent Memory 评估测试方案：从指标体系到开源基准">Agent Memory 评估测试方案：从指标体系到开源基准</a><time datetime="2025-10-24T08:38:29.000Z" title="发表于 2025-10-24 16:38:29">2025-10-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/17/Preventing-Memory-Drift-in-Agent-Systems-Three-Core-Techniques-and-Engineering-Implementations/" title="Agent 如何避免记忆漂移：三大策略与工程实践">Agent 如何避免记忆漂移：三大策略与工程实践</a><time datetime="2025-10-17T08:17:39.000Z" title="发表于 2025-10-17 16:17:39">2025-10-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/15/What-Is-a-Multi-Agent-System-From-a-Single-LLM-to-Collaborative-Intelligence/" title="什么是多 Agent 系统？从单体模型到协作智能的进化">什么是多 Agent 系统？从单体模型到协作智能的进化</a><time datetime="2025-10-15T08:11:28.000Z" title="发表于 2025-10-15 16:11:28">2025-10-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/10/Understanding_Agent_Memory_The_Mechanisms_Behind_AI%E2%80%99s_Ability_to_Remember/" title="什么是 Agent Memory？探索 AI 如何理解并记住你的话">什么是 Agent Memory？探索 AI 如何理解并记住你的话</a><time datetime="2025-10-10T08:18:47.000Z" title="发表于 2025-10-10 16:18:47">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Luhui芦荟</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">浙ICP备19010836号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: '4987f0fb0a509fb9f0af',
      clientSecret: '7e264967a3ea557003aacdf795b9e57e36a56382',
      repo: 'ldinglding.github.io',
      owner: 'LDingLDing',
      admin: ['LDingLDing'],
      id: '682c0fdb87bd4fa561daafa9bb988843',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>